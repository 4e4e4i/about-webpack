# Webpack (version 2.0)

Webpack - сборщик модулей на проекте. Обычно ваш проект состоит из JS файлов, стилей, шаблонизаторов
и тд. Помимо этого все эти модули переплетены зависимостями и после того, как эти файлы пройдут через
webpack, мы получим просто основные статические сущности, которые правильно разложены по зависимостям.  

![webpack_scheme](assets/webpack.png)


## Что предоставляет Webpack

* Поддержка модулей (так же он поддерживает нативный ES6 синтаксис)

    * AMD
    * Common.js
    
* Пакетные мендеджеры (может спокойной подключать различные библиотеки, которые были установлены за
счет данных пакетных менеджеров)

    * NPM
    * Bower
    
* Live Reload (это обновление контента без перезагрузки страницы браузера)

    * Hot Module Replacement (если поменяем JS код, то окно бразера не перезагрузится, а изменения
    будут пременены)


### Какие проблемы решает Webpack

* Правильный порядок скриптов (сам смотрит на зависимости скриптов и подключает в правильно порядке)
* Правильные зависимости подключены
* (на каждой странице)
* Лимит подключения скриптов
* Без использования пакетных менеджеров приходилось копировать исходный код библиотке

### Что такое Webpack

* Webpack инструмент для совмещения модулей, а не таск раннер (как gulp или grunt)

* Анализирует дерево зависимостей (не только JS, но и CSS, картинки, HTML и тд)

* Понимает разные стандарты модулей (Common.js, AMD ...)

* Webpack2 понимает ES6 импорты и экспорты

### Зачем он был разработан

* Разделение кода (декомпозиция) и загрузка модулей по требованию
* Уменьшение скорости загрузки страниц (объединение модулей, минификация)
* Статические сущности (шрифты, картинки) - тоже модули которые можно обрабатывать
* Понимание NodeJS модулей (для работы со сторонними библиотеками)
* Подходит для больших проектов

### Различия

* Может использовать NPM
* У каждого модуля есть свои зависимости, которые Webpack отлично понимает
* Нет глобальных переменных (если мы сами их не создадим)
* Все загружается в нужном порядке (если нет рекурсии)
* Возможность тестирования каждого меодуля отдельно

#### Первый запуск

Установка глобально пакета Webpack и в папке с файлами js можно выполнить webpack init.js -o out.js,
чтобы собрать все файлы в один bundle.

### Командные интерфейсы webpack

В данной команде webpack по дефолту создает файл для продакшена и сразу минифицырует выходной бандл,
чтобы собрать файл для разработки необходимо задать mode development:
```
webpack --mode=development init.js -o out-d.js
```

Для того чтобы войти в режим "вотчинга" за изменениями в файлах js мы так же можем прописать команду
```
webpack init.js -o out-d.js -d --watch
```

Теперь при любых изменениях в файлах, вебпак будет пересобирать данный bundle

#### Source maps

C помощью команды мы можем добавить в модули функцию eval, которая компилирует входящую строку и добавляет
source map (работает с открытой консолью):

```
webpack init.js -o out-d.js -d
```

Подсветка в консоле с помощью команды

```
webpack init.js -o out-d.js --colors
```

### Работа с Webpack config

Для этого необходимо в корне проекта на одном уровне с папкой src создать файл webpack.config.js

Основная особенность данного файла (из-за того что он работает на платформе NodeJS) он должен экспортировать
из себя некий объект, делается это с помощью конструкции module.exports. В NodeJS единичный js файл
является модулем и у него есть глобальный объект module, у которого есть объект exports, в который мы можем положить
объект:

```
module.exports = {}
```

И далее в этом объекте мы будем описывать ключи в синтаксисе JS и значения - конфигурация webpack'а

* Сначала установим точку входа через ключ **entry** - это наш init.js.
* Для того чтобы webpack смог найти наш файл, который, например находится в папке src, нам необходимо подключить 
специальный модуль, который встроен в nodeJS - path в начале файла.

```
const path = require('path')
```
и  помощью данного модуля мы будем указывать пути и разрешать их удобным способом. Так же добавим поле context
которое будет говорить вебпаку о том, где находится данный файл абсолютным путем. В ней мы укажем path.resolve,
для того чтобы он нам разрулил путь, в резолв мы укажем глобальную переменную в NodeJS - __dirname, которая будет отвечать
за путь к данной директории и вторым параметром саму папку src

```
module.exports = {
    context: path.resolve(__dirname, 'src')
}    
```

* Далее как основной параметр, который должен пристуствовать - свойство output, которое является объектом и
у него есть 2 свойства: filename - название файла бандла и path - путь где разместить данный bundle

```
module.exports = {
    context: path.resolve(__dirname, 'src'),
    
    entry: './init.js',
    
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist')
    }
}    
```

Рассмотрим еще 2 конфигурации. Это поле resolve - объект, у него есть поле extensions - array и здесь
мы можем указать строку '.js'. Данный параметр прописывается по-умолчанию, он означает, что мы можем подключать
какие-либо определенные сущности, т.е. когда мы делаем импорты картинок, стилей или скриптов, вебпак разрешает не писать
формат файла в пути благодаря данному параметру.

И еще один параметр - watch. По умолчанию - false, он позволяет компилировать бандл на лету.

#### Множественные точки входа

Например если есть сайт, у которого множество страниц и на каждой странице используются определенные скрипты. При этом
есть библиотеки общие, которые хотелось бы использовать в рамках одного проекта.

Для того чтобы использовать несколько точек входа, поле entry может принимать объект и каждый ключ - точка входа,
а его значение - путь до файла js.

Для того чтобы получить несколько бандлов, у вебпака есть небольшой такой шаблонизатор, в output поле filename мы
в строке укажем [name].js, то бандлы будут называться исходя из названий ключей, указанных в entry.

#### Исходные карты

Можно добавлять дополнительное поле devtool со значением 'eval' для первого типа исходных карт.
Следующий тип карт - 'source-map'. Создает отдельный файл map с исходными картами. Есть и другие, можно посмотреть в документации.

#### Подключение плагинов

С помощью плагинов можно расширять функционал вебпака. 

Например подефолту в вебпак мы можем импортировать файл, названный с заглавной буквы, с прописной.
То есть, если мы создали Module.js и импортируем в init.js 

```
impot 'module.js'
```

Вебпак без ошибок создаст бандл, и это не есть правильно. Потому что проект могут разрабатывать на разных ОС
и данная фишка не прокатит. Для таких случаев существует плагин.
Для этого потребуется подключить npm и установить пакет с данным плагином с зависимостью для разработки.

```
npm i --save-dev case-sensitive-paths-webpack-plugin
```

Затем подключить данный пакет в webpack.config.js. И затем в корне выходного объекта, в поле plugins, которое является массивом,
добавить экземпляр данного плагина через ключевое слово **new** и вызвать его

```
const path = require('path');
const CaseSensitivePathsWebpackPlugin = require('case-sensitive-paths-webpack-plugin')

module.exports = {
    context: path.resolve(__dirname, 'src'),

    entry: './init.js',

    mode: 'none',

    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist')
    },

    plugins: [
        new CaseSensitivePathsWebpackPlugin()
    ]
}
```
Теперь вебпак будет вызывать ошибку, если импортируются модули с различными регистрами в названии файлов.

Так же у Вебпака есть свои собственные плагины и для того чтобы ими пользоваться необходимо установить
вебпак локально. 

```
npm i --save-dev webpack
```

Подключить пакет вебпака в webpack.config.js. И теперь можно воспользоваться его плагинами.
Например подключим плагин для минификации кода

```javascript
 const path = require('path');
 const webpack = require('webpack')
 
 module.exports = {
     context: path.resolve(__dirname, 'src'),
 
     entry: './init.js',
 
     mode: 'none',
 
     output: {
         filename: 'bundle.js',
         path: path.resolve(__dirname, 'dist')
     },
 
     plugins: [
         new webpack.optimize.UglifyJsPlagin()
     ]
 }

```

в новой версии Webpack минимазация подключается через поле optimization
```javascript
module.exports = {
    // ...
    optimization: {
        minimize: true // This is true by default in production mode.
    }
}
```

Так же можно привести пример библиотеки jquery и добавить ее в наш проект

```
npm i --save jquery
```

В init.js добавим код
```javascript
import $ from 'jquery';

function StartApplication(someParams) {
    console.log(someParams);
    $('body').html(someParams);
}

StartApplication('Hello World!');
```

И теперь после использования команды webpack, у нас будет минифицирован даже код библиотеки.

#### Define & Provide Plugins

Для того чтобы исопльзовать данные плагины нам необходимо локально установить в devDependency webpack
и в конфинг фале в поле plugins добавить новый экземпляр класса webpack.DefinePlugin и в параметрах нужно будет
передать непосредственно в сам конструктор класса объект:

```javascript
const path = require('path');
const webpack = require('webpack');

module.exports = {

    context: path.join(__dirname, 'src'),
    entry: './init.js',

    mode: 'none',

    output: {
        path: path.join(__dirname, 'dist'),
        filename: 'bundle.js'
    },

    optimization: {
        minimize: true
    },

    plugins: [
        new webpack.DefinePlugin({
        
        })
    ]
};

```

Данный плагин позволяет создавать импровизированные глобальные переменные для проекта. По факту они буду локальные,
т.е. в консоле в devtools мы не сможем их найти, одна по всему проекту они будут глобальными.

Как это будет выглядеть, например мы хотим создать поле VERSION т.е. версию нашего проекта, и например в его значение добавить
строку '0.0.2', так же добавим флаг PRODUCTION со значением false, и флаг HTML5_SUPPORT со значением true:

```javascript
module.exports = {
    //...
    plugins: [
        new webpack.DefinePlugin({
            VERSION: '0.0.2',
            PRODUCTION: false,
            HTML5_SUPPORT: true
        })
    ]
}
```  

Теперь если мы хотим воспользоваться данными переменными в самом коде, то в файле init.js можем написать следующее:

```javascript
function init() {

    if (!PRODUCTION) {
        console.log(VERSION);
    }

    console.log('html5', HTML5_SUPPORT);
}
``` 

Теперь после сборки наши переменные будут заменены на значения полей указанных в плагине, но единственная коллизия произошла
с переменной версии, мы хотели видеть строку, а получили число. Для этого нужно указать webpack явно, что значение данного
поля - строка. Поэтому в значении поля мы можем обратиться к глобальному объекту JSON и его свойству stringify

```javascript
new webpack.DefinePlugin({
    VERSION: JSON.stringify('0.0.2'),
    PRODUCTION: false,
    HTML5_SUPPORT: true
})
```
Данная функция позволяет переводить в JSON стиль и webpack понимает, что это именно строка.

Так же давайте создаим еще один файл, например a.js и напишем внутри него условие :

```javascript
if (!PRODUCTION) {
    alert(HTML5_SUPPORT);
}
```

И импортируем данный файл в init.js

```javascript
import './a';
```

Если бы в условие пришло булин false, то вебпак даже бы не стал заходить в него и компилировать внутренний код.

Следующий плагин, который мы рассмотрим называется ProvidePlugin, он так же в конструкторе принимает в себя объект,
и в нем мы можем указать ту или иную библиотеку, которая установлена в папке node_modules, например если мы установили jquery:

```javascript
module.exports = {
    plugins: [
        new webpack.ProvidePlugin({
            $: 'jquery'
        })
    ]
}
```

Так мы можем в файле init.js просто обратиться к функционалу jquery не подключая ее в самом файле:

```javascript
function init() {
    $('body').html(VERSION);
}
```

Конечно, ProvidePlugin не рекомендуется использовать ко всему, потому что лучше подключать библиотеки непосредственно туда,
где они необходимы, а вот DefinePlugin очень удобен и позволяет сократить какой-нибудь код. 
